From cfdeed4ae4cd4d93b8f75e78769272b60acf6d85 Mon Sep 17 00:00:00 2001
From: Strit <strit@manjaro.org>
Date: Tue, 9 Jul 2019 13:59:14 +0200
Subject: [PATCH 2/2] fix some logitiech usb keyboards

---
 drivers/hid/hid-logitech-dj.c | 1183 +++++++--------------------------
 1 file changed, 239 insertions(+), 944 deletions(-)

diff --git a/drivers/hid/hid-logitech-dj.c b/drivers/hid/hid-logitech-dj.c
index bfcf2ee58d14..826fa1e1c8d9 100644
--- a/drivers/hid/hid-logitech-dj.c
+++ b/drivers/hid/hid-logitech-dj.c
@@ -1,23 +1,37 @@
-// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  HID driver for Logitech Unifying receivers
  *
  *  Copyright (c) 2011 Logitech
  */
 
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
 
 
 #include <linux/device.h>
 #include <linux/hid.h>
 #include <linux/module.h>
+#include <linux/usb.h>
 #include <linux/kfifo.h>
-#include <linux/delay.h>
-#include <linux/usb.h> /* For to_usb_interface for kvm extra intf check */
 #include <asm/unaligned.h>
 #include "hid-ids.h"
 
 #define DJ_MAX_PAIRED_DEVICES			6
-#define DJ_MAX_NUMBER_NOTIFS			8
+#define DJ_MAX_NUMBER_NOTIFICATIONS		8
 #define DJ_RECEIVER_INDEX			0
 #define DJ_DEVICE_INDEX_MIN			1
 #define DJ_DEVICE_INDEX_MAX			6
@@ -30,7 +44,6 @@
 
 #define REPORT_ID_HIDPP_SHORT			0x10
 #define REPORT_ID_HIDPP_LONG			0x11
-#define REPORT_ID_HIDPP_VERY_LONG		0x12
 
 #define HIDPP_REPORT_SHORT_LENGTH		7
 #define HIDPP_REPORT_LONG_LENGTH		20
@@ -61,6 +74,7 @@
 /* Device Un-Paired Notification */
 #define REPORT_TYPE_NOTIF_DEVICE_UNPAIRED	0x40
 
+
 /* Connection Status Notification */
 #define REPORT_TYPE_NOTIF_CONNECTION_STATUS	0x42
 #define CONNECTION_STATUS_PARAM_STATUS		0x00
@@ -80,44 +94,12 @@
 #define REPORT_TYPE_LEDS			0x0E
 
 /* RF Report types bitfield */
-#define STD_KEYBOARD				BIT(1)
-#define STD_MOUSE				BIT(2)
-#define MULTIMEDIA				BIT(3)
-#define POWER_KEYS				BIT(4)
-#define MEDIA_CENTER				BIT(8)
-#define KBD_LEDS				BIT(14)
-/* Fake (bitnr > NUMBER_OF_HID_REPORTS) bit to track HID++ capability */
-#define HIDPP					BIT_ULL(63)
-
-/* HID++ Device Connected Notification */
-#define REPORT_TYPE_NOTIF_DEVICE_CONNECTED	0x41
-#define HIDPP_PARAM_PROTO_TYPE			0x00
-#define HIDPP_PARAM_DEVICE_INFO			0x01
-#define HIDPP_PARAM_EQUAD_LSB			0x02
-#define HIDPP_PARAM_EQUAD_MSB			0x03
-#define HIDPP_PARAM_27MHZ_DEVID			0x03
-#define HIDPP_DEVICE_TYPE_MASK			GENMASK(3, 0)
-#define HIDPP_LINK_STATUS_MASK			BIT(6)
-#define HIDPP_MANUFACTURER_MASK			BIT(7)
-
-#define HIDPP_DEVICE_TYPE_KEYBOARD		1
-#define HIDPP_DEVICE_TYPE_MOUSE			2
-
-#define HIDPP_SET_REGISTER			0x80
-#define HIDPP_GET_LONG_REGISTER			0x83
-#define HIDPP_REG_CONNECTION_STATE		0x02
-#define HIDPP_REG_PAIRING_INFORMATION		0xB5
-#define HIDPP_PAIRING_INFORMATION		0x20
-#define HIDPP_FAKE_DEVICE_ARRIVAL		0x02
-
-enum recvr_type {
-	recvr_type_dj,
-	recvr_type_hidpp,
-	recvr_type_gaming_hidpp,
-	recvr_type_mouse_only,
-	recvr_type_27mhz,
-	recvr_type_bluetooth,
-};
+#define STD_KEYBOARD				0x00000002
+#define STD_MOUSE				0x00000004
+#define MULTIMEDIA				0x00000008
+#define POWER_KEYS				0x00000010
+#define MEDIA_CENTER				0x00000100
+#define KBD_LEDS				0x00004000
 
 struct dj_report {
 	u8 report_id;
@@ -126,51 +108,23 @@ struct dj_report {
 	u8 report_params[DJREPORT_SHORT_LENGTH - 3];
 };
 
-struct hidpp_event {
-	u8 report_id;
-	u8 device_index;
-	u8 sub_id;
-	u8 params[HIDPP_REPORT_LONG_LENGTH - 3U];
-} __packed;
-
 struct dj_receiver_dev {
-	struct hid_device *mouse;
-	struct hid_device *keyboard;
-	struct hid_device *hidpp;
+	struct hid_device *hdev;
 	struct dj_device *paired_dj_devices[DJ_MAX_PAIRED_DEVICES +
 					    DJ_DEVICE_INDEX_MIN];
-	struct list_head list;
-	struct kref kref;
 	struct work_struct work;
 	struct kfifo notif_fifo;
-	unsigned long last_query; /* in jiffies */
-	bool ready;
-	enum recvr_type type;
-	unsigned int unnumbered_application;
 	spinlock_t lock;
+	bool querying_devices;
 };
 
 struct dj_device {
 	struct hid_device *hdev;
 	struct dj_receiver_dev *dj_receiver_dev;
-	u64 reports_supported;
+	u32 reports_supported;
 	u8 device_index;
 };
 
-#define WORKITEM_TYPE_EMPTY	0
-#define WORKITEM_TYPE_PAIRED	1
-#define WORKITEM_TYPE_UNPAIRED	2
-#define WORKITEM_TYPE_UNKNOWN	255
-
-struct dj_workitem {
-	u8 type;		/* WORKITEM_TYPE_* */
-	u8 device_index;
-	u8 device_type;
-	u8 quad_id_msb;
-	u8 quad_id_lsb;
-	u64 reports_supported;
-};
-
 /* Keyboard descriptor (1) */
 static const char kbd_descriptor[] = {
 	0x05, 0x01,		/* USAGE_PAGE (generic Desktop)     */
@@ -246,131 +200,6 @@ static const char mse_descriptor[] = {
 	0xC0,			/*  END_COLLECTION                      */
 };
 
-/* Mouse descriptor (2) for 27 MHz receiver, only 8 buttons */
-static const char mse_27mhz_descriptor[] = {
-	0x05, 0x01,		/*  USAGE_PAGE (Generic Desktop)        */
-	0x09, 0x02,		/*  USAGE (Mouse)                       */
-	0xA1, 0x01,		/*  COLLECTION (Application)            */
-	0x85, 0x02,		/*    REPORT_ID = 2                     */
-	0x09, 0x01,		/*    USAGE (pointer)                   */
-	0xA1, 0x00,		/*    COLLECTION (physical)             */
-	0x05, 0x09,		/*      USAGE_PAGE (buttons)            */
-	0x19, 0x01,		/*      USAGE_MIN (1)                   */
-	0x29, 0x08,		/*      USAGE_MAX (8)                   */
-	0x15, 0x00,		/*      LOGICAL_MIN (0)                 */
-	0x25, 0x01,		/*      LOGICAL_MAX (1)                 */
-	0x95, 0x08,		/*      REPORT_COUNT (8)                */
-	0x75, 0x01,		/*      REPORT_SIZE (1)                 */
-	0x81, 0x02,		/*      INPUT (data var abs)            */
-	0x05, 0x01,		/*      USAGE_PAGE (generic desktop)    */
-	0x16, 0x01, 0xF8,	/*      LOGICAL_MIN (-2047)             */
-	0x26, 0xFF, 0x07,	/*      LOGICAL_MAX (2047)              */
-	0x75, 0x0C,		/*      REPORT_SIZE (12)                */
-	0x95, 0x02,		/*      REPORT_COUNT (2)                */
-	0x09, 0x30,		/*      USAGE (X)                       */
-	0x09, 0x31,		/*      USAGE (Y)                       */
-	0x81, 0x06,		/*      INPUT                           */
-	0x15, 0x81,		/*      LOGICAL_MIN (-127)              */
-	0x25, 0x7F,		/*      LOGICAL_MAX (127)               */
-	0x75, 0x08,		/*      REPORT_SIZE (8)                 */
-	0x95, 0x01,		/*      REPORT_COUNT (1)                */
-	0x09, 0x38,		/*      USAGE (wheel)                   */
-	0x81, 0x06,		/*      INPUT                           */
-	0x05, 0x0C,		/*      USAGE_PAGE(consumer)            */
-	0x0A, 0x38, 0x02,	/*      USAGE(AC Pan)                   */
-	0x95, 0x01,		/*      REPORT_COUNT (1)                */
-	0x81, 0x06,		/*      INPUT                           */
-	0xC0,			/*    END_COLLECTION                    */
-	0xC0,			/*  END_COLLECTION                      */
-};
-
-/* Mouse descriptor (2) for Bluetooth receiver, low-res hwheel, 12 buttons */
-static const char mse_bluetooth_descriptor[] = {
-	0x05, 0x01,		/*  USAGE_PAGE (Generic Desktop)        */
-	0x09, 0x02,		/*  USAGE (Mouse)                       */
-	0xA1, 0x01,		/*  COLLECTION (Application)            */
-	0x85, 0x02,		/*    REPORT_ID = 2                     */
-	0x09, 0x01,		/*    USAGE (pointer)                   */
-	0xA1, 0x00,		/*    COLLECTION (physical)             */
-	0x05, 0x09,		/*      USAGE_PAGE (buttons)            */
-	0x19, 0x01,		/*      USAGE_MIN (1)                   */
-	0x29, 0x08,		/*      USAGE_MAX (8)                   */
-	0x15, 0x00,		/*      LOGICAL_MIN (0)                 */
-	0x25, 0x01,		/*      LOGICAL_MAX (1)                 */
-	0x95, 0x08,		/*      REPORT_COUNT (8)                */
-	0x75, 0x01,		/*      REPORT_SIZE (1)                 */
-	0x81, 0x02,		/*      INPUT (data var abs)            */
-	0x05, 0x01,		/*      USAGE_PAGE (generic desktop)    */
-	0x16, 0x01, 0xF8,	/*      LOGICAL_MIN (-2047)             */
-	0x26, 0xFF, 0x07,	/*      LOGICAL_MAX (2047)              */
-	0x75, 0x0C,		/*      REPORT_SIZE (12)                */
-	0x95, 0x02,		/*      REPORT_COUNT (2)                */
-	0x09, 0x30,		/*      USAGE (X)                       */
-	0x09, 0x31,		/*      USAGE (Y)                       */
-	0x81, 0x06,		/*      INPUT                           */
-	0x15, 0x81,		/*      LOGICAL_MIN (-127)              */
-	0x25, 0x7F,		/*      LOGICAL_MAX (127)               */
-	0x75, 0x08,		/*      REPORT_SIZE (8)                 */
-	0x95, 0x01,		/*      REPORT_COUNT (1)                */
-	0x09, 0x38,		/*      USAGE (wheel)                   */
-	0x81, 0x06,		/*      INPUT                           */
-	0x05, 0x0C,		/*      USAGE_PAGE(consumer)            */
-	0x0A, 0x38, 0x02,	/*      USAGE(AC Pan)                   */
-	0x15, 0xF9,		/*      LOGICAL_MIN (-7)                */
-	0x25, 0x07,		/*      LOGICAL_MAX (7)                 */
-	0x75, 0x04,		/*      REPORT_SIZE (4)                 */
-	0x95, 0x01,		/*      REPORT_COUNT (1)                */
-	0x81, 0x06,		/*      INPUT                           */
-	0x05, 0x09,		/*      USAGE_PAGE (buttons)            */
-	0x19, 0x09,		/*      USAGE_MIN (9)                   */
-	0x29, 0x0C,		/*      USAGE_MAX (12)                  */
-	0x15, 0x00,		/*      LOGICAL_MIN (0)                 */
-	0x25, 0x01,		/*      LOGICAL_MAX (1)                 */
-	0x75, 0x01,		/*      REPORT_SIZE (1)                 */
-	0x95, 0x04,		/*      REPORT_COUNT (4)                */
-	0x81, 0x06,		/*      INPUT                           */
-	0xC0,			/*    END_COLLECTION                    */
-	0xC0,			/*  END_COLLECTION                      */
-};
-
-/* Gaming Mouse descriptor (2) */
-static const char mse_high_res_descriptor[] = {
-	0x05, 0x01,		/*  USAGE_PAGE (Generic Desktop)        */
-	0x09, 0x02,		/*  USAGE (Mouse)                       */
-	0xA1, 0x01,		/*  COLLECTION (Application)            */
-	0x85, 0x02,		/*    REPORT_ID = 2                     */
-	0x09, 0x01,		/*    USAGE (pointer)                   */
-	0xA1, 0x00,		/*    COLLECTION (physical)             */
-	0x05, 0x09,		/*      USAGE_PAGE (buttons)            */
-	0x19, 0x01,		/*      USAGE_MIN (1)                   */
-	0x29, 0x10,		/*      USAGE_MAX (16)                  */
-	0x15, 0x00,		/*      LOGICAL_MIN (0)                 */
-	0x25, 0x01,		/*      LOGICAL_MAX (1)                 */
-	0x95, 0x10,		/*      REPORT_COUNT (16)               */
-	0x75, 0x01,		/*      REPORT_SIZE (1)                 */
-	0x81, 0x02,		/*      INPUT (data var abs)            */
-	0x05, 0x01,		/*      USAGE_PAGE (generic desktop)    */
-	0x16, 0x01, 0x80,	/*      LOGICAL_MIN (-32767)            */
-	0x26, 0xFF, 0x7F,	/*      LOGICAL_MAX (32767)             */
-	0x75, 0x10,		/*      REPORT_SIZE (16)                */
-	0x95, 0x02,		/*      REPORT_COUNT (2)                */
-	0x09, 0x30,		/*      USAGE (X)                       */
-	0x09, 0x31,		/*      USAGE (Y)                       */
-	0x81, 0x06,		/*      INPUT                           */
-	0x15, 0x81,		/*      LOGICAL_MIN (-127)              */
-	0x25, 0x7F,		/*      LOGICAL_MAX (127)               */
-	0x75, 0x08,		/*      REPORT_SIZE (8)                 */
-	0x95, 0x01,		/*      REPORT_COUNT (1)                */
-	0x09, 0x38,		/*      USAGE (wheel)                   */
-	0x81, 0x06,		/*      INPUT                           */
-	0x05, 0x0C,		/*      USAGE_PAGE(consumer)            */
-	0x0A, 0x38, 0x02,	/*      USAGE(AC Pan)                   */
-	0x95, 0x01,		/*      REPORT_COUNT (1)                */
-	0x81, 0x06,		/*      INPUT                           */
-	0xC0,			/*    END_COLLECTION                    */
-	0xC0,			/*  END_COLLECTION                      */
-};
-
 /* Consumer Control descriptor (3) */
 static const char consumer_descriptor[] = {
 	0x05, 0x0C,		/* USAGE_PAGE (Consumer Devices)       */
@@ -479,7 +308,7 @@ static const char hidpp_descriptor[] = {
 /* Make sure all descriptors are present here */
 #define MAX_RDESC_SIZE				\
 	(sizeof(kbd_descriptor) +		\
-	 sizeof(mse_bluetooth_descriptor) +	\
+	 sizeof(mse_descriptor) +		\
 	 sizeof(consumer_descriptor) +		\
 	 sizeof(syscontrol_descriptor) +	\
 	 sizeof(media_descriptor) +	\
@@ -512,160 +341,51 @@ static const u8 hid_reportid_size_map[NUMBER_OF_HID_REPORTS] = {
 static struct hid_ll_driver logi_dj_ll_driver;
 
 static int logi_dj_recv_query_paired_devices(struct dj_receiver_dev *djrcv_dev);
-static void delayedwork_callback(struct work_struct *work);
-
-static LIST_HEAD(dj_hdev_list);
-static DEFINE_MUTEX(dj_hdev_list_lock);
-
-/*
- * dj/HID++ receivers are really a single logical entity, but for BIOS/Windows
- * compatibility they have multiple USB interfaces. On HID++ receivers we need
- * to listen for input reports on both interfaces. The functions below are used
- * to create a single struct dj_receiver_dev for all interfaces belonging to
- * a single USB-device / receiver.
- */
-static struct dj_receiver_dev *dj_find_receiver_dev(struct hid_device *hdev,
-						    enum recvr_type type)
-{
-	struct dj_receiver_dev *djrcv_dev;
-	char sep;
-
-	/*
-	 * The bluetooth receiver contains a built-in hub and has separate
-	 * USB-devices for the keyboard and mouse interfaces.
-	 */
-	sep = (type == recvr_type_bluetooth) ? '.' : '/';
-
-	/* Try to find an already-probed interface from the same device */
-	list_for_each_entry(djrcv_dev, &dj_hdev_list, list) {
-		if (djrcv_dev->mouse &&
-		    hid_compare_device_paths(hdev, djrcv_dev->mouse, sep)) {
-			kref_get(&djrcv_dev->kref);
-			return djrcv_dev;
-		}
-		if (djrcv_dev->keyboard &&
-		    hid_compare_device_paths(hdev, djrcv_dev->keyboard, sep)) {
-			kref_get(&djrcv_dev->kref);
-			return djrcv_dev;
-		}
-		if (djrcv_dev->hidpp &&
-		    hid_compare_device_paths(hdev, djrcv_dev->hidpp, sep)) {
-			kref_get(&djrcv_dev->kref);
-			return djrcv_dev;
-		}
-	}
-
-	return NULL;
-}
-
-static void dj_release_receiver_dev(struct kref *kref)
-{
-	struct dj_receiver_dev *djrcv_dev = container_of(kref, struct dj_receiver_dev, kref);
-
-	list_del(&djrcv_dev->list);
-	kfifo_free(&djrcv_dev->notif_fifo);
-	kfree(djrcv_dev);
-}
-
-static void dj_put_receiver_dev(struct hid_device *hdev)
-{
-	struct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);
-
-	mutex_lock(&dj_hdev_list_lock);
-
-	if (djrcv_dev->mouse == hdev)
-		djrcv_dev->mouse = NULL;
-	if (djrcv_dev->keyboard == hdev)
-		djrcv_dev->keyboard = NULL;
-	if (djrcv_dev->hidpp == hdev)
-		djrcv_dev->hidpp = NULL;
-
-	kref_put(&djrcv_dev->kref, dj_release_receiver_dev);
-
-	mutex_unlock(&dj_hdev_list_lock);
-}
-
-static struct dj_receiver_dev *dj_get_receiver_dev(struct hid_device *hdev,
-						   enum recvr_type type,
-						   unsigned int application,
-						   bool is_hidpp)
-{
-	struct dj_receiver_dev *djrcv_dev;
-
-	mutex_lock(&dj_hdev_list_lock);
-
-	djrcv_dev = dj_find_receiver_dev(hdev, type);
-	if (!djrcv_dev) {
-		djrcv_dev = kzalloc(sizeof(*djrcv_dev), GFP_KERNEL);
-		if (!djrcv_dev)
-			goto out;
-
-		INIT_WORK(&djrcv_dev->work, delayedwork_callback);
-		spin_lock_init(&djrcv_dev->lock);
-		if (kfifo_alloc(&djrcv_dev->notif_fifo,
-			    DJ_MAX_NUMBER_NOTIFS * sizeof(struct dj_workitem),
-			    GFP_KERNEL)) {
-			kfree(djrcv_dev);
-			djrcv_dev = NULL;
-			goto out;
-		}
-		kref_init(&djrcv_dev->kref);
-		list_add_tail(&djrcv_dev->list, &dj_hdev_list);
-		djrcv_dev->last_query = jiffies;
-		djrcv_dev->type = type;
-	}
-
-	if (application == HID_GD_KEYBOARD)
-		djrcv_dev->keyboard = hdev;
-	if (application == HID_GD_MOUSE)
-		djrcv_dev->mouse = hdev;
-	if (is_hidpp)
-		djrcv_dev->hidpp = hdev;
-
-	hid_set_drvdata(hdev, djrcv_dev);
-out:
-	mutex_unlock(&dj_hdev_list_lock);
-	return djrcv_dev;
-}
 
 static void logi_dj_recv_destroy_djhid_device(struct dj_receiver_dev *djrcv_dev,
-					      struct dj_workitem *workitem)
+						struct dj_report *dj_report)
 {
 	/* Called in delayed work context */
 	struct dj_device *dj_dev;
 	unsigned long flags;
 
 	spin_lock_irqsave(&djrcv_dev->lock, flags);
-	dj_dev = djrcv_dev->paired_dj_devices[workitem->device_index];
-	djrcv_dev->paired_dj_devices[workitem->device_index] = NULL;
+	dj_dev = djrcv_dev->paired_dj_devices[dj_report->device_index];
+	djrcv_dev->paired_dj_devices[dj_report->device_index] = NULL;
 	spin_unlock_irqrestore(&djrcv_dev->lock, flags);
 
 	if (dj_dev != NULL) {
 		hid_destroy_device(dj_dev->hdev);
 		kfree(dj_dev);
 	} else {
-		hid_err(djrcv_dev->hidpp, "%s: can't destroy a NULL device\n",
+		dev_err(&djrcv_dev->hdev->dev, "%s: can't destroy a NULL device\n",
 			__func__);
 	}
 }
 
 static void logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,
-					  struct dj_workitem *workitem)
+					  struct dj_report *dj_report)
 {
 	/* Called in delayed work context */
-	struct hid_device *djrcv_hdev = djrcv_dev->hidpp;
+	struct hid_device *djrcv_hdev = djrcv_dev->hdev;
+	struct usb_interface *intf = to_usb_interface(djrcv_hdev->dev.parent);
+	struct usb_device *usbdev = interface_to_usbdev(intf);
 	struct hid_device *dj_hiddev;
 	struct dj_device *dj_dev;
-	u8 device_index = workitem->device_index;
-	unsigned long flags;
 
 	/* Device index goes from 1 to 6, we need 3 bytes to store the
 	 * semicolon, the index, and a null terminator
 	 */
 	unsigned char tmpstr[3];
 
-	/* We are the only one ever adding a device, no need to lock */
-	if (djrcv_dev->paired_dj_devices[device_index]) {
+	if (dj_report->report_params[DEVICE_PAIRED_PARAM_SPFUNCTION] &
+	    SPFUNCTION_DEVICE_LIST_EMPTY) {
+		dbg_hid("%s: device list is empty\n", __func__);
+		djrcv_dev->querying_devices = false;
+		return;
+	}
+
+	if (djrcv_dev->paired_dj_devices[dj_report->device_index]) {
 		/* The device is already known. No need to reallocate it. */
 		dbg_hid("%s: device is already known\n", __func__);
 		return;
@@ -673,7 +393,8 @@ static void logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,
 
 	dj_hiddev = hid_allocate_device();
 	if (IS_ERR(dj_hiddev)) {
-		hid_err(djrcv_hdev, "%s: hid_allocate_dev failed\n", __func__);
+		dev_err(&djrcv_hdev->dev, "%s: hid_allocate_device failed\n",
+			__func__);
 		return;
 	}
 
@@ -681,67 +402,48 @@ static void logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,
 
 	dj_hiddev->dev.parent = &djrcv_hdev->dev;
 	dj_hiddev->bus = BUS_USB;
-	dj_hiddev->vendor = djrcv_hdev->vendor;
-	dj_hiddev->product = (workitem->quad_id_msb << 8) |
-			      workitem->quad_id_lsb;
-	if (workitem->device_type) {
-		const char *type_str = "Device";
-
-		switch (workitem->device_type) {
-		case 0x01: type_str = "Keyboard";	break;
-		case 0x02: type_str = "Mouse";		break;
-		case 0x03: type_str = "Numpad";		break;
-		case 0x04: type_str = "Presenter";	break;
-		case 0x07: type_str = "Remote Control";	break;
-		case 0x08: type_str = "Trackball";	break;
-		case 0x09: type_str = "Touchpad";	break;
-		}
-		snprintf(dj_hiddev->name, sizeof(dj_hiddev->name),
-			"Logitech Wireless %s PID:%04x",
-			type_str, dj_hiddev->product);
-	} else {
-		snprintf(dj_hiddev->name, sizeof(dj_hiddev->name),
-			"Logitech Unifying Device. Wireless PID:%04x",
-			dj_hiddev->product);
-	}
-
-	if (djrcv_dev->type == recvr_type_27mhz)
-		dj_hiddev->group = HID_GROUP_LOGITECH_27MHZ_DEVICE;
-	else
-		dj_hiddev->group = HID_GROUP_LOGITECH_DJ_DEVICE;
-
-	memcpy(dj_hiddev->phys, djrcv_hdev->phys, sizeof(djrcv_hdev->phys));
-	snprintf(tmpstr, sizeof(tmpstr), ":%d", device_index);
+	dj_hiddev->vendor = le16_to_cpu(usbdev->descriptor.idVendor);
+	dj_hiddev->product =
+		(dj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_MSB]
+									<< 8) |
+		dj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_LSB];
+	snprintf(dj_hiddev->name, sizeof(dj_hiddev->name),
+		"Logitech Unifying Device. Wireless PID:%04x",
+		dj_hiddev->product);
+
+	dj_hiddev->group = HID_GROUP_LOGITECH_DJ_DEVICE;
+
+	usb_make_path(usbdev, dj_hiddev->phys, sizeof(dj_hiddev->phys));
+	snprintf(tmpstr, sizeof(tmpstr), ":%d", dj_report->device_index);
 	strlcat(dj_hiddev->phys, tmpstr, sizeof(dj_hiddev->phys));
 
 	dj_dev = kzalloc(sizeof(struct dj_device), GFP_KERNEL);
 
 	if (!dj_dev) {
-		hid_err(djrcv_hdev, "%s: failed allocating dj_dev\n", __func__);
+		dev_err(&djrcv_hdev->dev, "%s: failed allocating dj_device\n",
+			__func__);
 		goto dj_device_allocate_fail;
 	}
 
-	dj_dev->reports_supported = workitem->reports_supported;
+	dj_dev->reports_supported = get_unaligned_le32(
+		dj_report->report_params + DEVICE_PAIRED_RF_REPORT_TYPE);
 	dj_dev->hdev = dj_hiddev;
 	dj_dev->dj_receiver_dev = djrcv_dev;
-	dj_dev->device_index = device_index;
+	dj_dev->device_index = dj_report->device_index;
 	dj_hiddev->driver_data = dj_dev;
 
-	spin_lock_irqsave(&djrcv_dev->lock, flags);
-	djrcv_dev->paired_dj_devices[device_index] = dj_dev;
-	spin_unlock_irqrestore(&djrcv_dev->lock, flags);
+	djrcv_dev->paired_dj_devices[dj_report->device_index] = dj_dev;
 
 	if (hid_add_device(dj_hiddev)) {
-		hid_err(djrcv_hdev, "%s: failed adding dj_device\n", __func__);
+		dev_err(&djrcv_hdev->dev, "%s: failed adding dj_device\n",
+			__func__);
 		goto hid_add_device_fail;
 	}
 
 	return;
 
 hid_add_device_fail:
-	spin_lock_irqsave(&djrcv_dev->lock, flags);
-	djrcv_dev->paired_dj_devices[device_index] = NULL;
-	spin_unlock_irqrestore(&djrcv_dev->lock, flags);
+	djrcv_dev->paired_dj_devices[dj_report->device_index] = NULL;
 	kfree(dj_dev);
 dj_device_allocate_fail:
 	hid_destroy_device(dj_hiddev);
@@ -752,7 +454,7 @@ static void delayedwork_callback(struct work_struct *work)
 	struct dj_receiver_dev *djrcv_dev =
 		container_of(work, struct dj_receiver_dev, work);
 
-	struct dj_workitem workitem;
+	struct dj_report dj_report;
 	unsigned long flags;
 	int count;
 	int retval;
@@ -761,234 +463,67 @@ static void delayedwork_callback(struct work_struct *work)
 
 	spin_lock_irqsave(&djrcv_dev->lock, flags);
 
-	/*
-	 * Since we attach to multiple interfaces, we may get scheduled before
-	 * we are bound to the HID++ interface, catch this.
-	 */
-	if (!djrcv_dev->ready) {
-		pr_warn("%s: delayedwork queued before hidpp interface was enumerated\n",
-			__func__);
-		spin_unlock_irqrestore(&djrcv_dev->lock, flags);
-		return;
-	}
-
-	count = kfifo_out(&djrcv_dev->notif_fifo, &workitem, sizeof(workitem));
+	count = kfifo_out(&djrcv_dev->notif_fifo, &dj_report,
+				sizeof(struct dj_report));
 
-	if (count != sizeof(workitem)) {
+	if (count != sizeof(struct dj_report)) {
+		dev_err(&djrcv_dev->hdev->dev, "%s: workitem triggered without "
+			"notifications available\n", __func__);
 		spin_unlock_irqrestore(&djrcv_dev->lock, flags);
 		return;
 	}
 
-	if (!kfifo_is_empty(&djrcv_dev->notif_fifo))
-		schedule_work(&djrcv_dev->work);
+	if (!kfifo_is_empty(&djrcv_dev->notif_fifo)) {
+		if (schedule_work(&djrcv_dev->work) == 0) {
+			dbg_hid("%s: did not schedule the work item, was "
+				"already queued\n", __func__);
+		}
+	}
 
 	spin_unlock_irqrestore(&djrcv_dev->lock, flags);
 
-	switch (workitem.type) {
-	case WORKITEM_TYPE_PAIRED:
-		logi_dj_recv_add_djhid_device(djrcv_dev, &workitem);
+	switch (dj_report.report_type) {
+	case REPORT_TYPE_NOTIF_DEVICE_PAIRED:
+		logi_dj_recv_add_djhid_device(djrcv_dev, &dj_report);
 		break;
-	case WORKITEM_TYPE_UNPAIRED:
-		logi_dj_recv_destroy_djhid_device(djrcv_dev, &workitem);
+	case REPORT_TYPE_NOTIF_DEVICE_UNPAIRED:
+		logi_dj_recv_destroy_djhid_device(djrcv_dev, &dj_report);
 		break;
-	case WORKITEM_TYPE_UNKNOWN:
+	default:
+	/* A normal report (i. e. not belonging to a pair/unpair notification)
+	 * arriving here, means that the report arrived but we did not have a
+	 * paired dj_device associated to the report's device_index, this
+	 * means that the original "device paired" notification corresponding
+	 * to this dj_device never arrived to this driver. The reason is that
+	 * hid-core discards all packets coming from a device while probe() is
+	 * executing. */
+	if (!djrcv_dev->paired_dj_devices[dj_report.device_index]) {
+		/* ok, we don't know the device, just re-ask the
+		 * receiver for the list of connected devices. */
 		retval = logi_dj_recv_query_paired_devices(djrcv_dev);
-		if (retval) {
-			hid_err(djrcv_dev->hidpp, "%s: logi_dj_recv_query_paired_devices error: %d\n",
-				__func__, retval);
+		if (!retval) {
+			/* everything went fine, so just leave */
+			break;
 		}
-		break;
-	case WORKITEM_TYPE_EMPTY:
-		dbg_hid("%s: device list is empty\n", __func__);
-		break;
+		dev_err(&djrcv_dev->hdev->dev,
+			"%s:logi_dj_recv_query_paired_devices "
+			"error:%d\n", __func__, retval);
+		}
+		dbg_hid("%s: unexpected report type\n", __func__);
 	}
 }
 
-/*
- * Sometimes we receive reports for which we do not have a paired dj_device
- * associated with the device_index or report-type to forward the report to.
- * This means that the original "device paired" notification corresponding
- * to the dj_device never arrived to this driver. Possible reasons for this are:
- * 1) hid-core discards all packets coming from a device during probe().
- * 2) if the receiver is plugged into a KVM switch then the pairing reports
- * are only forwarded to it if the focus is on this PC.
- * This function deals with this by re-asking the receiver for the list of
- * connected devices in the delayed work callback.
- * This function MUST be called with djrcv->lock held.
- */
-static void logi_dj_recv_queue_unknown_work(struct dj_receiver_dev *djrcv_dev)
-{
-	struct dj_workitem workitem = { .type = WORKITEM_TYPE_UNKNOWN };
-
-	/* Rate limit queries done because of unhandeled reports to 2/sec */
-	if (time_before(jiffies, djrcv_dev->last_query + HZ / 2))
-		return;
-
-	kfifo_in(&djrcv_dev->notif_fifo, &workitem, sizeof(workitem));
-	schedule_work(&djrcv_dev->work);
-}
-
 static void logi_dj_recv_queue_notification(struct dj_receiver_dev *djrcv_dev,
 					   struct dj_report *dj_report)
 {
 	/* We are called from atomic context (tasklet && djrcv->lock held) */
-	struct dj_workitem workitem = {
-		.device_index = dj_report->device_index,
-	};
-
-	switch (dj_report->report_type) {
-	case REPORT_TYPE_NOTIF_DEVICE_PAIRED:
-		workitem.type = WORKITEM_TYPE_PAIRED;
-		if (dj_report->report_params[DEVICE_PAIRED_PARAM_SPFUNCTION] &
-		    SPFUNCTION_DEVICE_LIST_EMPTY) {
-			workitem.type = WORKITEM_TYPE_EMPTY;
-			break;
-		}
-		/* fall-through */
-	case REPORT_TYPE_NOTIF_DEVICE_UNPAIRED:
-		workitem.quad_id_msb =
-			dj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_MSB];
-		workitem.quad_id_lsb =
-			dj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_LSB];
-		workitem.reports_supported = get_unaligned_le32(
-						dj_report->report_params +
-						DEVICE_PAIRED_RF_REPORT_TYPE);
-		workitem.reports_supported |= HIDPP;
-		if (dj_report->report_type == REPORT_TYPE_NOTIF_DEVICE_UNPAIRED)
-			workitem.type = WORKITEM_TYPE_UNPAIRED;
-		break;
-	default:
-		logi_dj_recv_queue_unknown_work(djrcv_dev);
-		return;
-	}
 
-	kfifo_in(&djrcv_dev->notif_fifo, &workitem, sizeof(workitem));
-	schedule_work(&djrcv_dev->work);
-}
-
-static void logi_hidpp_dev_conn_notif_equad(struct hid_device *hdev,
-					    struct hidpp_event *hidpp_report,
-					    struct dj_workitem *workitem)
-{
-	struct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);
-
-	workitem->type = WORKITEM_TYPE_PAIRED;
-	workitem->device_type = hidpp_report->params[HIDPP_PARAM_DEVICE_INFO] &
-				HIDPP_DEVICE_TYPE_MASK;
-	workitem->quad_id_msb = hidpp_report->params[HIDPP_PARAM_EQUAD_MSB];
-	workitem->quad_id_lsb = hidpp_report->params[HIDPP_PARAM_EQUAD_LSB];
-	switch (workitem->device_type) {
-	case REPORT_TYPE_KEYBOARD:
-		workitem->reports_supported |= STD_KEYBOARD | MULTIMEDIA |
-					       POWER_KEYS | MEDIA_CENTER |
-					       HIDPP;
-		break;
-	case REPORT_TYPE_MOUSE:
-		workitem->reports_supported |= STD_MOUSE | HIDPP;
-		if (djrcv_dev->type == recvr_type_mouse_only)
-			workitem->reports_supported |= MULTIMEDIA;
-		break;
-	}
-}
-
-static void logi_hidpp_dev_conn_notif_27mhz(struct hid_device *hdev,
-					    struct hidpp_event *hidpp_report,
-					    struct dj_workitem *workitem)
-{
-	workitem->type = WORKITEM_TYPE_PAIRED;
-	workitem->quad_id_lsb = hidpp_report->params[HIDPP_PARAM_27MHZ_DEVID];
-	switch (hidpp_report->device_index) {
-	case 1: /* Index 1 is always a mouse */
-	case 2: /* Index 2 is always a mouse */
-		workitem->device_type = HIDPP_DEVICE_TYPE_MOUSE;
-		workitem->reports_supported |= STD_MOUSE | HIDPP;
-		break;
-	case 3: /* Index 3 is always the keyboard */
-	case 4: /* Index 4 is used for an optional separate numpad */
-		workitem->device_type = HIDPP_DEVICE_TYPE_KEYBOARD;
-		workitem->reports_supported |= STD_KEYBOARD | MULTIMEDIA |
-					       POWER_KEYS | HIDPP;
-		break;
-	default:
-		hid_warn(hdev, "%s: unexpected device-index %d", __func__,
-			 hidpp_report->device_index);
-	}
-}
-
-static void logi_hidpp_recv_queue_notif(struct hid_device *hdev,
-					struct hidpp_event *hidpp_report)
-{
-	/* We are called from atomic context (tasklet && djrcv->lock held) */
-	struct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);
-	const char *device_type = "UNKNOWN";
-	struct dj_workitem workitem = {
-		.type = WORKITEM_TYPE_EMPTY,
-		.device_index = hidpp_report->device_index,
-	};
-
-	switch (hidpp_report->params[HIDPP_PARAM_PROTO_TYPE]) {
-	case 0x01:
-		device_type = "Bluetooth";
-		/* Bluetooth connect packet contents is the same as (e)QUAD */
-		logi_hidpp_dev_conn_notif_equad(hdev, hidpp_report, &workitem);
-		if (!(hidpp_report->params[HIDPP_PARAM_DEVICE_INFO] &
-						HIDPP_MANUFACTURER_MASK)) {
-			hid_info(hdev, "Non Logitech device connected on slot %d\n",
-				 hidpp_report->device_index);
-			workitem.reports_supported &= ~HIDPP;
-		}
-		break;
-	case 0x02:
-		device_type = "27 Mhz";
-		logi_hidpp_dev_conn_notif_27mhz(hdev, hidpp_report, &workitem);
-		break;
-	case 0x03:
-		device_type = "QUAD or eQUAD";
-		logi_hidpp_dev_conn_notif_equad(hdev, hidpp_report, &workitem);
-		break;
-	case 0x04:
-		device_type = "eQUAD step 4 DJ";
-		logi_hidpp_dev_conn_notif_equad(hdev, hidpp_report, &workitem);
-		break;
-	case 0x05:
-		device_type = "DFU Lite";
-		break;
-	case 0x06:
-		device_type = "eQUAD step 4 Lite";
-		logi_hidpp_dev_conn_notif_equad(hdev, hidpp_report, &workitem);
-		break;
-	case 0x07:
-		device_type = "eQUAD step 4 Gaming";
-		break;
-	case 0x08:
-		device_type = "eQUAD step 4 for gamepads";
-		break;
-	case 0x0a:
-		device_type = "eQUAD nano Lite";
-		logi_hidpp_dev_conn_notif_equad(hdev, hidpp_report, &workitem);
-		break;
-	case 0x0c:
-		device_type = "eQUAD Lightspeed";
-		logi_hidpp_dev_conn_notif_equad(hdev, hidpp_report, &workitem);
-		workitem.reports_supported |= STD_KEYBOARD;
-		break;
-	}
+	kfifo_in(&djrcv_dev->notif_fifo, dj_report, sizeof(struct dj_report));
 
-	if (workitem.type == WORKITEM_TYPE_EMPTY) {
-		hid_warn(hdev,
-			 "unusable device of type %s (0x%02x) connected on slot %d",
-			 device_type,
-			 hidpp_report->params[HIDPP_PARAM_PROTO_TYPE],
-			 hidpp_report->device_index);
-		return;
+	if (schedule_work(&djrcv_dev->work) == 0) {
+		dbg_hid("%s: did not schedule the work item, was already "
+			"queued\n", __func__);
 	}
-
-	hid_info(hdev, "device of type %s (0x%02x) connected on slot %d",
-		 device_type, hidpp_report->params[HIDPP_PARAM_PROTO_TYPE],
-		 hidpp_report->device_index);
-
-	kfifo_in(&djrcv_dev->notif_fifo, &workitem, sizeof(workitem));
-	schedule_work(&djrcv_dev->work);
 }
 
 static void logi_dj_recv_forward_null_report(struct dj_receiver_dev *djrcv_dev,
@@ -1017,8 +552,8 @@ static void logi_dj_recv_forward_null_report(struct dj_receiver_dev *djrcv_dev,
 	}
 }
 
-static void logi_dj_recv_forward_dj(struct dj_receiver_dev *djrcv_dev,
-				    struct dj_report *dj_report)
+static void logi_dj_recv_forward_report(struct dj_receiver_dev *djrcv_dev,
+					struct dj_report *dj_report)
 {
 	/* We are called from atomic context (tasklet && djrcv->lock held) */
 	struct dj_device *dj_device;
@@ -1038,48 +573,18 @@ static void logi_dj_recv_forward_dj(struct dj_receiver_dev *djrcv_dev,
 	}
 }
 
-static void logi_dj_recv_forward_report(struct dj_device *dj_dev, u8 *data,
-					int size)
+static void logi_dj_recv_forward_hidpp(struct dj_device *dj_dev, u8 *data,
+				       int size)
 {
 	/* We are called from atomic context (tasklet && djrcv->lock held) */
 	if (hid_input_report(dj_dev->hdev, HID_INPUT_REPORT, data, size, 1))
 		dbg_hid("hid_input_report error\n");
 }
 
-static void logi_dj_recv_forward_input_report(struct hid_device *hdev,
-					      u8 *data, int size)
-{
-	struct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);
-	struct dj_device *dj_dev;
-	unsigned long flags;
-	u8 report = data[0];
-	int i;
-
-	if (report > REPORT_TYPE_RFREPORT_LAST) {
-		hid_err(hdev, "Unexpected input report number %d\n", report);
-		return;
-	}
-
-	spin_lock_irqsave(&djrcv_dev->lock, flags);
-	for (i = 0; i < (DJ_MAX_PAIRED_DEVICES + DJ_DEVICE_INDEX_MIN); i++) {
-		dj_dev = djrcv_dev->paired_dj_devices[i];
-		if (dj_dev && (dj_dev->reports_supported & BIT(report))) {
-			logi_dj_recv_forward_report(dj_dev, data, size);
-			spin_unlock_irqrestore(&djrcv_dev->lock, flags);
-			return;
-		}
-	}
-
-	logi_dj_recv_queue_unknown_work(djrcv_dev);
-	spin_unlock_irqrestore(&djrcv_dev->lock, flags);
-
-	dbg_hid("No dj-devs handling input report number %d\n", report);
-}
-
 static int logi_dj_recv_send_report(struct dj_receiver_dev *djrcv_dev,
 				    struct dj_report *dj_report)
 {
-	struct hid_device *hdev = djrcv_dev->hidpp;
+	struct hid_device *hdev = djrcv_dev->hdev;
 	struct hid_report *report;
 	struct hid_report_enum *output_report_enum;
 	u8 *data = (u8 *)(&dj_report->device_index);
@@ -1089,7 +594,7 @@ static int logi_dj_recv_send_report(struct dj_receiver_dev *djrcv_dev,
 	report = output_report_enum->report_id_hash[REPORT_ID_DJ_SHORT];
 
 	if (!report) {
-		hid_err(hdev, "%s: unable to find dj report\n", __func__);
+		dev_err(&hdev->dev, "%s: unable to find dj report\n", __func__);
 		return -ENODEV;
 	}
 
@@ -1101,40 +606,14 @@ static int logi_dj_recv_send_report(struct dj_receiver_dev *djrcv_dev,
 	return 0;
 }
 
-static int logi_dj_recv_query_hidpp_devices(struct dj_receiver_dev *djrcv_dev)
-{
-	const u8 template[] = {REPORT_ID_HIDPP_SHORT,
-			       HIDPP_RECEIVER_INDEX,
-			       HIDPP_SET_REGISTER,
-			       HIDPP_REG_CONNECTION_STATE,
-			       HIDPP_FAKE_DEVICE_ARRIVAL,
-			       0x00, 0x00};
-	u8 *hidpp_report;
-	int retval;
-
-	hidpp_report = kmemdup(template, sizeof(template), GFP_KERNEL);
-	if (!hidpp_report)
-		return -ENOMEM;
-
-	retval = hid_hw_raw_request(djrcv_dev->hidpp,
-				    REPORT_ID_HIDPP_SHORT,
-				    hidpp_report, sizeof(template),
-				    HID_OUTPUT_REPORT,
-				    HID_REQ_SET_REPORT);
-
-	kfree(hidpp_report);
-	return 0;
-}
-
 static int logi_dj_recv_query_paired_devices(struct dj_receiver_dev *djrcv_dev)
 {
 	struct dj_report *dj_report;
 	int retval;
 
-	djrcv_dev->last_query = jiffies;
-
-	if (djrcv_dev->type != recvr_type_dj)
-		return logi_dj_recv_query_hidpp_devices(djrcv_dev);
+	/* no need to protect djrcv_dev->querying_devices */
+	if (djrcv_dev->querying_devices)
+		return 0;
 
 	dj_report = kzalloc(sizeof(struct dj_report), GFP_KERNEL);
 	if (!dj_report)
@@ -1151,33 +630,27 @@ static int logi_dj_recv_query_paired_devices(struct dj_receiver_dev *djrcv_dev)
 static int logi_dj_recv_switch_to_dj_mode(struct dj_receiver_dev *djrcv_dev,
 					  unsigned timeout)
 {
-	struct hid_device *hdev = djrcv_dev->hidpp;
+	struct hid_device *hdev = djrcv_dev->hdev;
 	struct dj_report *dj_report;
 	u8 *buf;
-	int retval = 0;
+	int retval;
 
 	dj_report = kzalloc(sizeof(struct dj_report), GFP_KERNEL);
 	if (!dj_report)
 		return -ENOMEM;
+	dj_report->report_id = REPORT_ID_DJ_SHORT;
+	dj_report->device_index = 0xFF;
+	dj_report->report_type = REPORT_TYPE_CMD_SWITCH;
+	dj_report->report_params[CMD_SWITCH_PARAM_DEVBITFIELD] = 0x3F;
+	dj_report->report_params[CMD_SWITCH_PARAM_TIMEOUT_SECONDS] = (u8)timeout;
+	retval = logi_dj_recv_send_report(djrcv_dev, dj_report);
 
-	if (djrcv_dev->type == recvr_type_dj) {
-		dj_report->report_id = REPORT_ID_DJ_SHORT;
-		dj_report->device_index = 0xFF;
-		dj_report->report_type = REPORT_TYPE_CMD_SWITCH;
-		dj_report->report_params[CMD_SWITCH_PARAM_DEVBITFIELD] = 0x3F;
-		dj_report->report_params[CMD_SWITCH_PARAM_TIMEOUT_SECONDS] =
-								(u8)timeout;
-
-		retval = logi_dj_recv_send_report(djrcv_dev, dj_report);
-
-		/*
-		 * Ugly sleep to work around a USB 3.0 bug when the receiver is
-		 * still processing the "switch-to-dj" command while we send an
-		 * other command.
-		 * 50 msec should gives enough time to the receiver to be ready.
-		 */
-		msleep(50);
-	}
+	/*
+	 * Ugly sleep to work around a USB 3.0 bug when the receiver is still
+	 * processing the "switch-to-dj" command while we send an other command.
+	 * 50 msec should gives enough time to the receiver to be ready.
+	 */
+	msleep(50);
 
 	/*
 	 * Magical bits to set up hidpp notifications when the dj devices
@@ -1209,28 +682,22 @@ static int logi_dj_recv_switch_to_dj_mode(struct dj_receiver_dev *djrcv_dev,
 
 static int logi_dj_ll_open(struct hid_device *hid)
 {
-	dbg_hid("%s: %s\n", __func__, hid->phys);
+	dbg_hid("%s:%s\n", __func__, hid->phys);
 	return 0;
 
 }
 
 static void logi_dj_ll_close(struct hid_device *hid)
 {
-	dbg_hid("%s: %s\n", __func__, hid->phys);
+	dbg_hid("%s:%s\n", __func__, hid->phys);
 }
 
 /*
  * Register 0xB5 is "pairing information". It is solely intended for the
  * receiver, so do not overwrite the device index.
  */
-static u8 unifying_pairing_query[]  = { REPORT_ID_HIDPP_SHORT,
-					HIDPP_RECEIVER_INDEX,
-					HIDPP_GET_LONG_REGISTER,
-					HIDPP_REG_PAIRING_INFORMATION };
-static u8 unifying_pairing_answer[] = { REPORT_ID_HIDPP_LONG,
-					HIDPP_RECEIVER_INDEX,
-					HIDPP_GET_LONG_REGISTER,
-					HIDPP_REG_PAIRING_INFORMATION };
+static u8 unifying_pairing_query[]  = {0x10, 0xff, 0x83, 0xb5};
+static u8 unifying_pairing_answer[] = {0x11, 0xff, 0x83, 0xb5};
 
 static int logi_dj_ll_raw_request(struct hid_device *hid,
 				  unsigned char reportnum, __u8 *buf,
@@ -1243,8 +710,7 @@ static int logi_dj_ll_raw_request(struct hid_device *hid,
 	int ret;
 
 	if ((buf[0] == REPORT_ID_HIDPP_SHORT) ||
-	    (buf[0] == REPORT_ID_HIDPP_LONG) ||
-	    (buf[0] == REPORT_ID_HIDPP_VERY_LONG)) {
+	    (buf[0] == REPORT_ID_HIDPP_LONG)) {
 		if (count < 2)
 			return -EINVAL;
 
@@ -1255,23 +721,13 @@ static int logi_dj_ll_raw_request(struct hid_device *hid,
 			buf[4] = (buf[4] & 0xf0) | (djdev->device_index - 1);
 		else
 			buf[1] = djdev->device_index;
-		return hid_hw_raw_request(djrcv_dev->hidpp, reportnum, buf,
+		return hid_hw_raw_request(djrcv_dev->hdev, reportnum, buf,
 				count, report_type, reqtype);
 	}
 
 	if (buf[0] != REPORT_TYPE_LEDS)
 		return -EINVAL;
 
-	if (djrcv_dev->type != recvr_type_dj && count >= 2) {
-		if (!djrcv_dev->keyboard) {
-			hid_warn(hid, "Received REPORT_TYPE_LEDS request before the keyboard interface was enumerated\n");
-			return 0;
-		}
-		/* usbhid overrides the report ID and ignores the first byte */
-		return hid_hw_raw_request(djrcv_dev->keyboard, 0, buf, count,
-					  report_type, reqtype);
-	}
-
 	out_buf = kzalloc(DJREPORT_SHORT_LENGTH, GFP_ATOMIC);
 	if (!out_buf)
 		return -ENOMEM;
@@ -1283,7 +739,7 @@ static int logi_dj_ll_raw_request(struct hid_device *hid,
 	out_buf[1] = djdev->device_index;
 	memcpy(out_buf + 2, buf, count);
 
-	ret = hid_hw_raw_request(djrcv_dev->hidpp, out_buf[0], out_buf,
+	ret = hid_hw_raw_request(djrcv_dev->hdev, out_buf[0], out_buf,
 		DJREPORT_SHORT_LENGTH, report_type, reqtype);
 
 	kfree(out_buf);
@@ -1313,56 +769,41 @@ static int logi_dj_ll_parse(struct hid_device *hid)
 		return -ENOMEM;
 
 	if (djdev->reports_supported & STD_KEYBOARD) {
-		dbg_hid("%s: sending a kbd descriptor, reports_supported: %llx\n",
+		dbg_hid("%s: sending a kbd descriptor, reports_supported: %x\n",
 			__func__, djdev->reports_supported);
 		rdcat(rdesc, &rsize, kbd_descriptor, sizeof(kbd_descriptor));
 	}
 
 	if (djdev->reports_supported & STD_MOUSE) {
-		dbg_hid("%s: sending a mouse descriptor, reports_supported: %llx\n",
-			__func__, djdev->reports_supported);
-		if (djdev->dj_receiver_dev->type == recvr_type_gaming_hidpp ||
-		    djdev->dj_receiver_dev->type == recvr_type_mouse_only)
-			rdcat(rdesc, &rsize, mse_high_res_descriptor,
-			      sizeof(mse_high_res_descriptor));
-		else if (djdev->dj_receiver_dev->type == recvr_type_27mhz)
-			rdcat(rdesc, &rsize, mse_27mhz_descriptor,
-			      sizeof(mse_27mhz_descriptor));
-		else if (djdev->dj_receiver_dev->type == recvr_type_bluetooth)
-			rdcat(rdesc, &rsize, mse_bluetooth_descriptor,
-			      sizeof(mse_bluetooth_descriptor));
-		else
-			rdcat(rdesc, &rsize, mse_descriptor,
-			      sizeof(mse_descriptor));
+		dbg_hid("%s: sending a mouse descriptor, reports_supported: "
+			"%x\n", __func__, djdev->reports_supported);
+		rdcat(rdesc, &rsize, mse_descriptor, sizeof(mse_descriptor));
 	}
 
 	if (djdev->reports_supported & MULTIMEDIA) {
-		dbg_hid("%s: sending a multimedia report descriptor: %llx\n",
+		dbg_hid("%s: sending a multimedia report descriptor: %x\n",
 			__func__, djdev->reports_supported);
 		rdcat(rdesc, &rsize, consumer_descriptor, sizeof(consumer_descriptor));
 	}
 
 	if (djdev->reports_supported & POWER_KEYS) {
-		dbg_hid("%s: sending a power keys report descriptor: %llx\n",
+		dbg_hid("%s: sending a power keys report descriptor: %x\n",
 			__func__, djdev->reports_supported);
 		rdcat(rdesc, &rsize, syscontrol_descriptor, sizeof(syscontrol_descriptor));
 	}
 
 	if (djdev->reports_supported & MEDIA_CENTER) {
-		dbg_hid("%s: sending a media center report descriptor: %llx\n",
+		dbg_hid("%s: sending a media center report descriptor: %x\n",
 			__func__, djdev->reports_supported);
 		rdcat(rdesc, &rsize, media_descriptor, sizeof(media_descriptor));
 	}
 
 	if (djdev->reports_supported & KBD_LEDS) {
-		dbg_hid("%s: need to send kbd leds report descriptor: %llx\n",
+		dbg_hid("%s: need to send kbd leds report descriptor: %x\n",
 			__func__, djdev->reports_supported);
 	}
 
-	if (djdev->reports_supported & HIDPP) {
-		rdcat(rdesc, &rsize, hidpp_descriptor,
-		      sizeof(hidpp_descriptor));
-	}
+	rdcat(rdesc, &rsize, hidpp_descriptor, sizeof(hidpp_descriptor));
 
 	retval = hid_parse_report(hid, rdesc, rsize);
 	kfree(rdesc);
@@ -1425,7 +866,7 @@ static int logi_dj_dj_event(struct hid_device *hdev,
 		 * so ignore those reports too.
 		 */
 		if (dj_report->device_index != DJ_RECEIVER_INDEX)
-			hid_err(hdev, "%s: invalid device index:%d\n",
+			dev_err(&hdev->dev, "%s: invalid device index:%d\n",
 				__func__, dj_report->device_index);
 		return false;
 	}
@@ -1452,7 +893,7 @@ static int logi_dj_dj_event(struct hid_device *hdev,
 		}
 		break;
 	default:
-		logi_dj_recv_forward_dj(djrcv_dev, dj_report);
+		logi_dj_recv_forward_report(djrcv_dev, dj_report);
 	}
 
 out:
@@ -1466,10 +907,9 @@ static int logi_dj_hidpp_event(struct hid_device *hdev,
 			     int size)
 {
 	struct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);
-	struct hidpp_event *hidpp_report = (struct hidpp_event *) data;
-	struct dj_device *dj_dev;
+	struct dj_report *dj_report = (struct dj_report *) data;
 	unsigned long flags;
-	u8 device_index = hidpp_report->device_index;
+	u8 device_index = dj_report->device_index;
 
 	if (device_index == HIDPP_RECEIVER_INDEX) {
 		/* special case were the device wants to know its unifying
@@ -1497,42 +937,21 @@ static int logi_dj_hidpp_event(struct hid_device *hdev,
 		 * This driver can ignore safely the receiver notifications,
 		 * so ignore those reports too.
 		 */
-		hid_err(hdev, "%s: invalid device index:%d\n", __func__,
-			hidpp_report->device_index);
+		dev_err(&hdev->dev, "%s: invalid device index:%d\n",
+				__func__, dj_report->device_index);
 		return false;
 	}
 
 	spin_lock_irqsave(&djrcv_dev->lock, flags);
 
-	dj_dev = djrcv_dev->paired_dj_devices[device_index];
-
-	/*
-	 * With 27 MHz receivers, we do not get an explicit unpair event,
-	 * remove the old device if the user has paired a *different* device.
-	 */
-	if (djrcv_dev->type == recvr_type_27mhz && dj_dev &&
-	    hidpp_report->sub_id == REPORT_TYPE_NOTIF_DEVICE_CONNECTED &&
-	    hidpp_report->params[HIDPP_PARAM_PROTO_TYPE] == 0x02 &&
-	    hidpp_report->params[HIDPP_PARAM_27MHZ_DEVID] !=
-						dj_dev->hdev->product) {
-		struct dj_workitem workitem = {
-			.device_index = hidpp_report->device_index,
-			.type = WORKITEM_TYPE_UNPAIRED,
-		};
-		kfifo_in(&djrcv_dev->notif_fifo, &workitem, sizeof(workitem));
-		/* logi_hidpp_recv_queue_notif will queue the work */
-		dj_dev = NULL;
-	}
+	if (!djrcv_dev->paired_dj_devices[device_index])
+		/* received an event for an unknown device, bail out */
+		goto out;
 
-	if (dj_dev) {
-		logi_dj_recv_forward_report(dj_dev, data, size);
-	} else {
-		if (hidpp_report->sub_id == REPORT_TYPE_NOTIF_DEVICE_CONNECTED)
-			logi_hidpp_recv_queue_notif(hdev, hidpp_report);
-		else
-			logi_dj_recv_queue_unknown_work(djrcv_dev);
-	}
+	logi_dj_recv_forward_hidpp(djrcv_dev->paired_dj_devices[device_index],
+				   data, size);
 
+out:
 	spin_unlock_irqrestore(&djrcv_dev->lock, flags);
 
 	return false;
@@ -1542,181 +961,112 @@ static int logi_dj_raw_event(struct hid_device *hdev,
 			     struct hid_report *report, u8 *data,
 			     int size)
 {
-	struct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);
 	dbg_hid("%s, size:%d\n", __func__, size);
 
-	if (!djrcv_dev)
-		return 0;
-
-	if (!hdev->report_enum[HID_INPUT_REPORT].numbered) {
-
-		if (djrcv_dev->unnumbered_application == HID_GD_KEYBOARD) {
-			/*
-			 * For the keyboard, we can reuse the same report by
-			 * using the second byte which is constant in the USB
-			 * HID report descriptor.
-			 */
-			data[1] = data[0];
-			data[0] = REPORT_TYPE_KEYBOARD;
-
-			logi_dj_recv_forward_input_report(hdev, data, size);
-
-			/* restore previous state */
-			data[0] = data[1];
-			data[1] = 0;
-		}
-		/*
-		 * Mouse-only receivers send unnumbered mouse data. The 27 MHz
-		 * receiver uses 6 byte packets, the nano receiver 8 bytes.
-		 */
-		if (djrcv_dev->unnumbered_application == HID_GD_MOUSE &&
-		    size <= 8) {
-			u8 mouse_report[9];
-
-			/* Prepend report id */
-			mouse_report[0] = REPORT_TYPE_MOUSE;
-			memcpy(mouse_report + 1, data, size);
-			logi_dj_recv_forward_input_report(hdev, mouse_report,
-							  size + 1);
-		}
-
-		return false;
-	}
-
 	switch (data[0]) {
 	case REPORT_ID_DJ_SHORT:
 		if (size != DJREPORT_SHORT_LENGTH) {
-			hid_err(hdev, "Short DJ report bad size (%d)", size);
-			return false;
-		}
-		return logi_dj_dj_event(hdev, report, data, size);
-	case REPORT_ID_DJ_LONG:
-		if (size != DJREPORT_LONG_LENGTH) {
-			hid_err(hdev, "Long DJ report bad size (%d)", size);
+			dev_err(&hdev->dev, "DJ report of bad size (%d)", size);
 			return false;
 		}
 		return logi_dj_dj_event(hdev, report, data, size);
 	case REPORT_ID_HIDPP_SHORT:
 		if (size != HIDPP_REPORT_SHORT_LENGTH) {
-			hid_err(hdev, "Short HID++ report bad size (%d)", size);
+			dev_err(&hdev->dev,
+				"Short HID++ report of bad size (%d)", size);
 			return false;
 		}
 		return logi_dj_hidpp_event(hdev, report, data, size);
 	case REPORT_ID_HIDPP_LONG:
 		if (size != HIDPP_REPORT_LONG_LENGTH) {
-			hid_err(hdev, "Long HID++ report bad size (%d)", size);
+			dev_err(&hdev->dev,
+				"Long HID++ report of bad size (%d)", size);
 			return false;
 		}
 		return logi_dj_hidpp_event(hdev, report, data, size);
 	}
 
-	logi_dj_recv_forward_input_report(hdev, data, size);
-
 	return false;
 }
 
 static int logi_dj_probe(struct hid_device *hdev,
 			 const struct hid_device_id *id)
 {
-	struct hid_report_enum *rep_enum;
-	struct hid_report *rep;
+	struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
 	struct dj_receiver_dev *djrcv_dev;
-	struct usb_interface *intf;
-	unsigned int no_dj_interfaces = 0;
-	bool has_hidpp = false;
-	unsigned long flags;
 	int retval;
 
-	/*
-	 * Call to usbhid to fetch the HID descriptors of the current
-	 * interface subsequently call to the hid/hid-core to parse the
-	 * fetched descriptors.
-	 */
-	retval = hid_parse(hdev);
-	if (retval) {
-		hid_err(hdev, "%s: parse failed\n", __func__);
-		return retval;
-	}
+	dbg_hid("%s called for ifnum %d\n", __func__,
+		intf->cur_altsetting->desc.bInterfaceNumber);
 
-	/*
-	 * Some KVMs add an extra interface for e.g. mouse emulation. If we
-	 * treat these as logitech-dj interfaces then this causes input events
-	 * reported through this extra interface to not be reported correctly.
-	 * To avoid this, we treat these as generic-hid devices.
-	 */
-	switch (id->driver_data) {
-	case recvr_type_dj:		no_dj_interfaces = 3; break;
-	case recvr_type_hidpp:		no_dj_interfaces = 2; break;
-	case recvr_type_gaming_hidpp:	no_dj_interfaces = 3; break;
-	case recvr_type_mouse_only:	no_dj_interfaces = 2; break;
-	case recvr_type_27mhz:		no_dj_interfaces = 2; break;
-	case recvr_type_bluetooth:	no_dj_interfaces = 2; break;
-	}
-	if (hid_is_using_ll_driver(hdev, &usb_hid_driver)) {
-		intf = to_usb_interface(hdev->dev.parent);
-		if (intf && intf->altsetting->desc.bInterfaceNumber >=
-							no_dj_interfaces) {
-			hdev->quirks |= HID_QUIRK_INPUT_PER_APP;
-			return hid_hw_start(hdev, HID_CONNECT_DEFAULT);
-		}
-	}
-
-	rep_enum = &hdev->report_enum[HID_INPUT_REPORT];
-
-	/* no input reports, bail out */
-	if (list_empty(&rep_enum->report_list))
+	/* Ignore interfaces 0 and 1, they will not carry any data, dont create
+	 * any hid_device for them */
+	if (intf->cur_altsetting->desc.bInterfaceNumber !=
+	    LOGITECH_DJ_INTERFACE_NUMBER) {
+		dbg_hid("%s: ignoring ifnum %d\n", __func__,
+			intf->cur_altsetting->desc.bInterfaceNumber);
 		return -ENODEV;
-
-	/*
-	 * Check for the HID++ application.
-	 * Note: we should theoretically check for HID++ and DJ
-	 * collections, but this will do.
-	 */
-	list_for_each_entry(rep, &rep_enum->report_list, list) {
-		if (rep->application == 0xff000001)
-			has_hidpp = true;
 	}
 
-	/*
-	 * Ignore interfaces without DJ/HID++ collection, they will not carry
-	 * any data, dont create any hid_device for them.
-	 */
-	if (!has_hidpp && id->driver_data == recvr_type_dj)
-		return -ENODEV;
+	/* Treat interface 2 */
 
-	/* get the current application attached to the node */
-	rep = list_first_entry(&rep_enum->report_list, struct hid_report, list);
-	djrcv_dev = dj_get_receiver_dev(hdev, id->driver_data,
-					rep->application, has_hidpp);
+	djrcv_dev = kzalloc(sizeof(struct dj_receiver_dev), GFP_KERNEL);
 	if (!djrcv_dev) {
-		hid_err(hdev, "%s: dj_get_receiver_dev failed\n", __func__);
+		dev_err(&hdev->dev,
+			"%s:failed allocating dj_receiver_dev\n", __func__);
+		return -ENOMEM;
+	}
+	djrcv_dev->hdev = hdev;
+	INIT_WORK(&djrcv_dev->work, delayedwork_callback);
+	spin_lock_init(&djrcv_dev->lock);
+	if (kfifo_alloc(&djrcv_dev->notif_fifo,
+			DJ_MAX_NUMBER_NOTIFICATIONS * sizeof(struct dj_report),
+			GFP_KERNEL)) {
+		dev_err(&hdev->dev,
+			"%s:failed allocating notif_fifo\n", __func__);
+		kfree(djrcv_dev);
 		return -ENOMEM;
 	}
+	hid_set_drvdata(hdev, djrcv_dev);
+
+	/* Call  to usbhid to fetch the HID descriptors of interface 2 and
+	 * subsequently call to the hid/hid-core to parse the fetched
+	 * descriptors, this will in turn create the hidraw and hiddev nodes
+	 * for interface 2 of the receiver */
+	retval = hid_parse(hdev);
+	if (retval) {
+		dev_err(&hdev->dev,
+			"%s:parse of interface 2 failed\n", __func__);
+		goto hid_parse_fail;
+	}
 
-	if (!rep_enum->numbered)
-		djrcv_dev->unnumbered_application = rep->application;
+	if (!hid_validate_values(hdev, HID_OUTPUT_REPORT, REPORT_ID_DJ_SHORT,
+				 0, DJREPORT_SHORT_LENGTH - 1)) {
+		retval = -ENODEV;
+		goto hid_parse_fail;
+	}
 
 	/* Starts the usb device and connects to upper interfaces hiddev and
 	 * hidraw */
-	retval = hid_hw_start(hdev, HID_CONNECT_HIDRAW|HID_CONNECT_HIDDEV);
+	retval = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
 	if (retval) {
-		hid_err(hdev, "%s: hid_hw_start returned error\n", __func__);
+		dev_err(&hdev->dev,
+			"%s:hid_hw_start returned error\n", __func__);
 		goto hid_hw_start_fail;
 	}
 
-	if (has_hidpp) {
-		retval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);
-		if (retval < 0) {
-			hid_err(hdev, "%s: logi_dj_recv_switch_to_dj_mode returned error:%d\n",
-				__func__, retval);
-			goto switch_to_dj_mode_fail;
-		}
+	retval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);
+	if (retval < 0) {
+		dev_err(&hdev->dev,
+			"%s:logi_dj_recv_switch_to_dj_mode returned error:%d\n",
+			__func__, retval);
+		goto switch_to_dj_mode_fail;
 	}
 
 	/* This is enabling the polling urb on the IN endpoint */
 	retval = hid_hw_open(hdev);
 	if (retval < 0) {
-		hid_err(hdev, "%s: hid_hw_open returned error:%d\n",
+		dev_err(&hdev->dev, "%s:hid_hw_open returned error:%d\n",
 			__func__, retval);
 		goto llopen_failed;
 	}
@@ -1724,16 +1074,11 @@ static int logi_dj_probe(struct hid_device *hdev,
 	/* Allow incoming packets to arrive: */
 	hid_device_io_start(hdev);
 
-	if (has_hidpp) {
-		spin_lock_irqsave(&djrcv_dev->lock, flags);
-		djrcv_dev->ready = true;
-		spin_unlock_irqrestore(&djrcv_dev->lock, flags);
-		retval = logi_dj_recv_query_paired_devices(djrcv_dev);
-		if (retval < 0) {
-			hid_err(hdev, "%s: logi_dj_recv_query_paired_devices error:%d\n",
-				__func__, retval);
-			goto logi_dj_recv_query_paired_devices_failed;
-		}
+	retval = logi_dj_recv_query_paired_devices(djrcv_dev);
+	if (retval < 0) {
+		dev_err(&hdev->dev, "%s:logi_dj_recv_query_paired_devices "
+			"error:%d\n", __func__, retval);
+		goto logi_dj_recv_query_paired_devices_failed;
 	}
 
 	return retval;
@@ -1746,8 +1091,12 @@ static int logi_dj_probe(struct hid_device *hdev,
 	hid_hw_stop(hdev);
 
 hid_hw_start_fail:
-	dj_put_receiver_dev(hdev);
+hid_parse_fail:
+	kfifo_free(&djrcv_dev->notif_fifo);
+	kfree(djrcv_dev);
+	hid_set_drvdata(hdev, NULL);
 	return retval;
+
 }
 
 #ifdef CONFIG_PM
@@ -1756,12 +1105,10 @@ static int logi_dj_reset_resume(struct hid_device *hdev)
 	int retval;
 	struct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);
 
-	if (!djrcv_dev || djrcv_dev->hidpp != hdev)
-		return 0;
-
 	retval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);
 	if (retval < 0) {
-		hid_err(hdev, "%s: logi_dj_recv_switch_to_dj_mode returned error:%d\n",
+		dev_err(&hdev->dev,
+			"%s:logi_dj_recv_switch_to_dj_mode returned error:%d\n",
 			__func__, retval);
 	}
 
@@ -1773,91 +1120,39 @@ static void logi_dj_remove(struct hid_device *hdev)
 {
 	struct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);
 	struct dj_device *dj_dev;
-	unsigned long flags;
 	int i;
 
 	dbg_hid("%s\n", __func__);
 
-	if (!djrcv_dev)
-		return hid_hw_stop(hdev);
-
-	/*
-	 * This ensures that if the work gets requeued from another
-	 * interface of the same receiver it will be a no-op.
-	 */
-	spin_lock_irqsave(&djrcv_dev->lock, flags);
-	djrcv_dev->ready = false;
-	spin_unlock_irqrestore(&djrcv_dev->lock, flags);
-
 	cancel_work_sync(&djrcv_dev->work);
 
 	hid_hw_close(hdev);
 	hid_hw_stop(hdev);
 
-	/*
-	 * For proper operation we need access to all interfaces, so we destroy
-	 * the paired devices when we're unbound from any interface.
-	 *
-	 * Note we may still be bound to other interfaces, sharing the same
-	 * djrcv_dev, so we need locking here.
-	 */
+	/* I suppose that at this point the only context that can access
+	 * the djrecv_data is this thread as the work item is guaranteed to
+	 * have finished and no more raw_event callbacks should arrive after
+	 * the remove callback was triggered so no locks are put around the
+	 * code below */
 	for (i = 0; i < (DJ_MAX_PAIRED_DEVICES + DJ_DEVICE_INDEX_MIN); i++) {
-		spin_lock_irqsave(&djrcv_dev->lock, flags);
 		dj_dev = djrcv_dev->paired_dj_devices[i];
-		djrcv_dev->paired_dj_devices[i] = NULL;
-		spin_unlock_irqrestore(&djrcv_dev->lock, flags);
 		if (dj_dev != NULL) {
 			hid_destroy_device(dj_dev->hdev);
 			kfree(dj_dev);
+			djrcv_dev->paired_dj_devices[i] = NULL;
 		}
 	}
 
-	dj_put_receiver_dev(hdev);
+	kfifo_free(&djrcv_dev->notif_fifo);
+	kfree(djrcv_dev);
+	hid_set_drvdata(hdev, NULL);
 }
 
 static const struct hid_device_id logi_dj_receivers[] = {
 	{HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,
-		USB_DEVICE_ID_LOGITECH_UNIFYING_RECEIVER),
-	 .driver_data = recvr_type_dj},
+		USB_DEVICE_ID_LOGITECH_UNIFYING_RECEIVER)},
 	{HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,
-		USB_DEVICE_ID_LOGITECH_UNIFYING_RECEIVER_2),
-	 .driver_data = recvr_type_dj},
-	{ /* Logitech Nano mouse only receiver */
-	  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,
-			 USB_DEVICE_ID_LOGITECH_NANO_RECEIVER),
-	 .driver_data = recvr_type_mouse_only},
-	{ /* Logitech Nano (non DJ) receiver */
-	  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,
-			 USB_DEVICE_ID_LOGITECH_NANO_RECEIVER_2),
-	 .driver_data = recvr_type_hidpp},
-	{ /* Logitech gaming receiver (0xc539) */
-	  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,
-		USB_DEVICE_ID_LOGITECH_NANO_RECEIVER_GAMING),
-	 .driver_data = recvr_type_gaming_hidpp},
-	{ /* Logitech 27 MHz HID++ 1.0 receiver (0xc517) */
-	  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,
-		USB_DEVICE_ID_S510_RECEIVER_2),
-	 .driver_data = recvr_type_27mhz},
-	{ /* Logitech 27 MHz HID++ 1.0 mouse-only receiver (0xc51b) */
-	  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,
-		USB_DEVICE_ID_LOGITECH_27MHZ_MOUSE_RECEIVER),
-	 .driver_data = recvr_type_27mhz},
-	{ /* Logitech MX5000 HID++ / bluetooth receiver keyboard intf. */
-	  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,
-		0xc70e),
-	 .driver_data = recvr_type_bluetooth},
-	{ /* Logitech MX5000 HID++ / bluetooth receiver mouse intf. */
-	  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,
-		0xc70a),
-	 .driver_data = recvr_type_bluetooth},
-	{ /* Logitech MX5500 HID++ / bluetooth receiver keyboard intf. */
-	  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,
-		0xc71b),
-	 .driver_data = recvr_type_bluetooth},
-	{ /* Logitech MX5500 HID++ / bluetooth receiver mouse intf. */
-	  HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH,
-		0xc71c),
-	 .driver_data = recvr_type_bluetooth},
+		USB_DEVICE_ID_LOGITECH_UNIFYING_RECEIVER_2)},
 	{}
 };
 
-- 
2.22.0

